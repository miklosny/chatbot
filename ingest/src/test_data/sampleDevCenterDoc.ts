export const devCenterDoc = {
  content:
    '## Motivation\n\nRealm offers several simple ways to provide third-party access to our data. One of them can be through the so-called [Webhooks](https://docs.mongodb.com/realm/services/configure/service-webhooks/). Through these, we could offer in a controlled way different endpoints to access our services and therefore our data.\n\nA real example would be to provide such webhooks to customers or partners so that they can access certain information necessary for the business logic existing within that particular use case.\n\nHowever, this way of solving this problem has certain disadvantages. The most important ones include:\n\n1. **Fixed-size for the response payload**: The size of the response cannot exceed **4 MB**. This limitation would prevent us from being able to query aggregated data that would require a response larger than 4 MB.\n2. **Creation of different endpoints for each business logic requirement**. This would not only pose a management problem, but also a maintenance problem: what if we make changes in the future? How do we manage the different versions? This model becomes more complex if we want to send parameters in the request to tailor the response to the requirements.\n\n***So what could be a more efficient solution?***\n\nRealm offers the possibility to use its GraphQL API to cover this and other needs. The advantages of using GraphQL for this use case could be listed as:\n\n1. An easier and simpler method to execute accurate endpoint calls.\n2. Easier to choose what we need in the response, alleviating the size of the response by not requiring unnecessary fields.\n3. Simpler maintenance.\n4. Avoid versioning.\n\n## What are we going to build?\n\nMaking use of the [sample available datasets in MongoDB](https://docs.atlas.mongodb.com/sample-data/available-sample-datasets/). We will build a filter to be able to return those movies that meet a set of requirements. These requirements are:\n\n1. Having a given IMDB rating.\n2. Belonging to a set of genres.\n3. Being a certain rate.\n4. Being in several available languages.\n\nThe filtering parameters will be dynamic so that we can return those that best fit our criteria.\n\nFor this, we will use a **GraphQL Custom Resolver** and an external client application to execute our queries.\n\n## Prerequisites\n\nThis tutorial will provide a step-by-step guide to run the demo. To do this we must follow these prerequisites:\n\n1. Have a Cloud MongoDB account.\n2. Create a Free Tier Cluster.\n3. Configure `realm-cli` .\n4. Add an API-Key to be able to access using `realm-cli`.\n5. Load initial data into the Cluster.\n\n### Create an Atlas Account\n\nTo begin, you’ll need a MongoDB Atlas account. If you’ve already got an existing MongoDB Atlas Account, you can skip this step and jump to [**Install the Realm CLI section**](#install-the-realm-cli). If you don’t have an Atlas account, follow the steps below to create one:\n\n1. Navigate to the [MongoDB Atlas login page](https://account.mongodb.com/account/register).\n2. Click Login.\n3. Either enter a new set of user credentials or click the Sign Up with Google button.\n4. Click Sign Up to create your account.\n5. Follow the prompts to create an organization and project in your Atlas account. You can use the default suggested names or enter your own.\n\n![Account startup screenshot](https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/0_A_Du4xd_Ay_MD_Ak_N3_B6_37497a6abc)\n\nWhen you finish creating your organization and project, you should end up on a screen that prompts you to create an Atlas cluster:\n\n![Free Tier Cluster screenshot](https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/0_tt_Wrkz45j_WO_Xag7_af1456d227)\n\n## Create a Free Atlas Cluster\n\nNext, you’ll need a MongoDB Atlas cluster running MongoDB 4.4 or higher. If you’ve already created a free cluster in your Atlas project running a version of MongoDB other than 4.4, you can [create a new project in Atlas](https://docs.atlas.mongodb.com/tutorial/manage-projects/#procedure) and then create a new cluster running MongoDB 4.4 in that project using the instructions below. If you haven’t created any clusters yet, follow the instructions below to create your first free cluster:\n\n1. Log into your MongoDB Atlas account at [cloud.mongodb.com](https://cloud.mongodb.com/).\n2. Once you’re logged into your account, Atlas should prompt you to create your first cluster. In the Shared Clusters category, click Create a Cluster. Alternatively, you can click Build a Cluster from the project view in your Atlas account.\n3. Under Cloud Provider & Region, select AWS and N. Virginia (us-east-1).\n4. Under Additional Settings, select MongoDB 4.4 from the Select a Version dropdown.\n5. Under Cluster Name, enter the name Cluster0 for your new cluster.\n6. Click the Create Cluster button at the bottom of the page.\n\nAfter creating your cluster, Atlas should launch the project view for your Atlas account. In this view, you’ll see Atlas’s progress as it initializes your new cluster:\n\n![Screenshot of a recently created cluster](https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/0_f9_B_Zh_Cw7_V7_XVR_8d_O_06a5e01c6c)\n\n## Install the Realm CLI\n\nNow that you’ve created a cluster to use as the data source for your Realm app, we need some way to create the app itself. In most cases, you’d use the Realm UI, which you can access through the Atlas UI. However, for this tutorial, we’re going to use the [Realm Command Line Interface](https://docs.mongodb.com/realm/deploy/realm-cli-reference/#std-label-realm-cli), also known as `realm-cli`.\n\nWe’re using the Realm CLI because it allows you to manage your Realm apps programmatically using JSON configuration files instead of the Realm UI.\n\nThis lets you get started with a pre-prepared app configuration faster. Follow the instructions below to install the Realm CLI in your development environment using either a package manager or the `realm-cli` binary:\n\nRealm CLI is available on npm. To install it on your system, ensure that you have [Node.js](https://nodejs.org/en/download/) installed and then run the following command in your shell:\n\n```\nnpm install -g mongodb-realm-cli@beta\n```\n\nAfter installing the `realm-cli`, you can run the following command to confirm that your installation was successful:\n\n```\nrealm-cli --version\n```\n\nIf you see output containing a version number such as `2.0.0-beta.4`, your `realm-cli` installation was successful.\n\n## Add an API Key to Your Atlas Project & Log into the Realm CLI\n\nNow that you’ve got `realm-cli`installed to your development environment, you’ll need a way to authenticate using `realm-cli`. For security reasons, `realm-cli`only allows login using a programmatic API key, so we’ll begin by creating a programmatic API Key that you can use to administrate your new Atlas project:\n\n* Click **Access Manager** at the top of the Atlas UI. Select the **Project Access** option from the dropdown.\n* Navigate to the **API Keys** tab.\n* Click the **Create API** Key button.\n* In the **Description** text box, enter “API Key for the MongoDB Realm CLI”.\n\n![Create API key screenshot in Realm UI](https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/0_GTFJ_7z_FF_2q_D_c_Zpd_935dddcc53)\n\n* In the **Project Permissions** dropdown, select “Project Owner” and deselect “Project Read Only”.\n\n![Project Permissions screenshot](https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/0_vr1_F4_D5e_Vhq_3we_efc619b9df)\n\n* Copy your Public API Key and save it somewhere.\n* Click **Next**.\n* Copy your Private API Key and save it somewhere; after leaving this page, you will no longer be able to view it via the Realm UI.\n* Click the **Add Access List Entry** button.\n* Click **Use Current IP Address**.\n* Click **Save**.\n* When you have safely recorded your private API key, click **Done** to navigate back to the Project Access Manager page.\n* Use the following command in your terminal to authenticate with the Realm CLI:\n\n``` bash\nrealm-cli login --api-key <public API key> --private-api-key <private API key>\n```\n\nIf `realm-cli` produces output like the following, you have successfully authenticated:\n\n```\nyou have successfully logged in as <public API key>\n```\n\n## Load sample dataset to the Cluster\n\nOnce we have deployed the Cluster, we can make use of the sample collections that MongoDB provides. To do this, we must click on “…” and “Load Sample Dataset”.\n\n![Load Sample Dataset screenshot](https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/0_7_T7_Ifl_Cl_Qr_BLYFDQ_bac2090539)\n\nThis process may take a few minutes due to the size of the sample collections. They are approximate \\~**350 MB**. Once it has finished, we can verify, by clicking on collections, that the [`sample_mflix.movies`](https://docs.atlas.mongodb.com/sample-data/sample-mflix/) the collection has been loaded successfully.\n\n![One document of Movie collection screenshot](https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/0_Eg4_Iaz_Vr_ELU_9p_CL_8_22cc39b57e)\n\nAnother way to check that the data has been loaded into our Cluster and interact with it can be by installing[ MongoDB Compass](https://www.mongodb.com/products/compass) or accessing it through a terminal and [Mongo shell](https://docs.mongodb.com/manual/mongo/).\n\n## Adding Rules to our collections\n\nTo use GraphQL, we need to configure rules for the collections that we are going to use, to do so we go to **DATA ACCESS** and **RULES** in Realm UI.\n\nWe then need to select the newest imported `sample_mflix.movies`collection and click on “**Configure Collection**”. We can configure it without selecting any Template (in the future we can make changes to it).\n\n![Rules section in Realm UI](https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/0_ky_Pqx_V0v_Ltossbn_R_a471fd8610)\n\nOnce the collection is selected and after clicking “**Configure Collection**”, we must select the “**All Additional Fields**” option and check the “**Read**” box. At this point, this will allow any authenticated user to read the data in this collection. This will be necessary to be able to later make requests through external clients such as Postman.\n\n![Rules section in Realm UI](https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/0_Hbqfhn_Rf_I_Ut_Kboco_311418b5df)\n\nAfter this step, we can configure the **Schema**. To do this and once in the “**Schema**” tab, we can use the documents already loaded in the collection for Realm to generate a schema from them.\n\n![Generate Schema in Realm UI](https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/0_u_Iqel7_Yf_V40_LY_5_V_b8e8601a29)\n\nAfter waiting a few minutes, we will be able to consult the Schema created on this same screen.\n\n![Schema generated for the movies collection](https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/0_O_Dpul_PC_Rs_Oe_Rip6l_b9d9631bef)\n\n## Add an authentication provider\n\nAll the requests that we are going to make through our GraphQL client must be authenticated. For this, we can activate any of the authentication providers available in Realm.\n\nFor this example, we will use **API Keys**, this way we could create an API Key for each of our clients/partners and disable access in the future if needed.\n\nOnce the authentication provider has been activated, we generate a new key and copy the value provided by the interface.\n\n![API Key Authentication Provider](https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/0_nl_S_Jvk_Cak0_Lz_Zc_H_ee0c35e7ba)\n\n## Testing GraphQL with GraphiQL\n\nRealm provides an embedded GraphiQL interface to test requests directly.\n\nThese requests do not need to be authenticated and allow you to test the requests before making them in a real scenario.\n\nTo check that everything is configured correctly, we can perform the following Query.\n\n```\nquery {\n  movie {\n    _id\n  }\n}\n```\n\nThis request is a simple Query to the movies collection where we are requesting to return just the `_id`. From a MongoDB point of view, this request could be equated to the following `mongoshell` method:\n\n``` javascript\ndb.movies.findOne({},{"_id" : 1})\n```\n\nOne of the advantages of using the GraphQL API in Realm is that it generates the Schema automatically for the configured collections. We can check this by navigating to the “**Schema**” tab in GraphQL and verifying that indeed the schema for the “**movies**” collection is generated. At this point, we can download the Schema for later use in a third-party GraphQL client such as Postman.\n\n## Create a custom resolver\n\nInthe description of our problem, we talk about how we need to detect in our dataset movies that correspond to a set of predefined filters. Up to this point, we could get all the movies from the dataset and perform some processing in a client application, but fortunately, we can make use of the *aggregation* *pipeline* in MongoDB to perform this transformation on the server through a custom resolver.\n\nIf we want to test the syntax needed to get all movies that match our filter we must perform this *aggregation*:\n\n``` javascript\n[{"$match": {\n  "imdb.rating": { "$gte": 7 },\n  "genres": { "$nin": [ "Crime", "Horror" ] } ,\n  "rated": { "$in": ["PG", "G" ] },\n  "languages": { "$all": [ "English", "Japanese" ] }\n  }\n}]\n```\n\nThe first step to perform is to “**Add a Custom Resolver**” in GraphQL.\n\n![Screenshot of Add Custom Resolver Screen in Realm](https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/0_CB_Gypxk_Nh_Hr_U_Ev63_4045da240d)\n\nThe fields to be filled in are the following:\n\n* **GraphQL Field Name**: This corresponds to the name we want to use when we refer to this custom resolver in our queries.\n* **Parent Type**: Type of custom resolver we are creating, in our case, being a read request, we will select Query.\n* **Function**: Here we create the function that will be called every time a call to our custom resolver is executed. You can link an existing function or create it here.\n\nThe code of the function would be the following:\n\n``` javascript\nexports = async function() {\n  const request = context.services.get(\'mongodb-atlas\').db(\'sample_mflix\').collection("movies");\n\n  const pipeline = [\n  {\n    "$match": {\n      "imdb.rating": { "$gte": 7 },\n      "genres": { "$nin": [ "Crime", "Horror" ] } ,\n      "rated": { "$in": ["PG", "G" ] },\n      "languages": { "$all": [ "English", "Japanese" ] }\n    }\n  }];\n\n  return await request.aggregate(pipeline).toArray()\n  .then(data => {\n    console.log(data.length);\n    return data;\n  })\n  .catch(err => {\n    console.log(err.toString());\n    return err.toString();\n  });\n};\n```\n\n![Screenshot of the Custom Resolver editor in Realm UI](https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/0_o_C_Hp9rkfhqd_Uj_Y_dc7a616c22)\n\n* **Input Type (Recommended)**: At the moment we will leave it at **None**. Later we will explain what we can do with it and what it is used for.\n* **Payload Type (Recommended)**: Type of object of the response. In our case, our *aggregate* will return a set of movies, therefore we choose **Existing Type (List)** and type **[Movie]**.\n\nAt this point, we can test our new **custom resolver** directly in Realm. To do this, in the same GraphiQL section we can write our query as follows:\n\n```\nquery {\n  oneTitleMovies {\n    title\n  }\n}\n```\n\nAfter clicking the Play button we should see the results of our query.\n\n![](https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/0_2_Og_Ewm_Vo_T_Mw_GR_8_YE_3a6eca2987)\n\n## Testing our newest created **Custom Resolver** in Postman\n\nTo test our query in an external client we will use Postman. There is a [tutorial](https://learning.postman.com/docs/sending-requests/supported-api-frameworks/graphql/) to make queries in Postman with an API/Schema. In this example, we will make a simple query without a schema and therefore we will not use it (but it is worth a look).\n\nTo test this query in Postman, we will create a new POST request where the URL is provided by Realm (GraphQL Endpoint). In the body of the request, we will select GraphQL and write:\n\n```\nquery {\n  oneTitleMovies {\n    title\n    cast\n  }\n}\n```\n\nWhen working with Realm and an external GraphQL client, we need to add some kind of **authentication.** In a previous step, we created an API Key as an authentication provider, although we can use any of them.\n\nIn the request headers, we should add:\n\n``` javascript\n{"apiKey","{{api_key}}"}\n```\n\nWhere we replace “*{{api\\_key}}*” with the value obtained previously.\n\nA general idea of what Postman’s cURL for this request would look like is:\n\n``` bash\ncurl --location --request POST \'[your_graphql_endpoint]\' \\\n --header \'apiKey: [your_api_key]\' \\\n --header \'Content-Type: application/json\' \\\n --data-raw \'{"query": "query {"query oneTitleMovies {"title" {"cast", "variables":{}}\'\n```\n\n![Postman request for a GraphQL query](https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/0_Mu_P4o_Gnc1g660_Z1_F_33761d1369)\n\n## Add an **Input Type** to our **Custom Resolver**\n\nWhen we created our custom resolver, we associated it to a function. This function had some preset parameters:\n\n1. “imdb.rating”: { $gte: 7 }\n2. genres: { $nin: [ “Crime”, “Horror” ] } ,\n3. rated: { $in: [ “PG”, “G” ] },\n4. languages: { $all: [ “English”, “Japanese” ] } }\n\nWe can create an **Input Type** of type **Custom Type** so that those values that are fixed for the moment can be sent by parameters. **Custom Types** must be defined as a Schema in a JSON object. For our use case, our Schema will be the following:\n\n``` json\n{\n  "bsonType": "object",\n  "title": "Filter",\n  "required" : [\n      "imdbRating",\n      "genres",\n      "rated"],\n  "properties": {\n    "imdbRating": {\n      "bsonType": "int"\n    },\n    "genres": {\n      "bsonType": "array",\n      "items": {\n        "bsonType": "string"\n      }\n    },\n    "rated": {\n      "bsonType": "array",\n      "items": {\n        "bsonType": "string"\n      }\n    },\n    "languages": {\n      "bsonType": "array",\n      "items": {\n        "bsonType": "string"\n      }\n    }\n  }\n}\n```\n\nWe will make the “IMDB.rating”, “genres” and “rated” fields mandatory so that they have to be always sent and the “languages” field will be optional.\n\n![Input Type of Custom Type in Custom Resolver](https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/0_R7_PGJ_98l_L4_C2x_Nlx_68abb12e92)\n\nTo be able to use the data sent by our new **Input Type**,we must modify the linked function so that we can receive them by parameters.\n\n``` javascript\nexports = async function({imdbRating, genres, rated, languages}) {\n\n  const request = context.services.get(\'mongodb-atlas\').db(\'sample_mflix\').collection(\'movies\');\n\n  const lang = languages === undefined ? ["English", "Japanese"] : languages;\n\n  const pipeline = [\n  {\n    $match: {\n      "imdb.rating": { "$gte": imdbRating },\n      "genres": { "$nin": genres } ,\n      "rated": { "$in": rated },\n      "languages": { "$all": lang }\n    }\n  }];\n\n  return await request.aggregate(pipeline).toArray()\n  .then(data => {\n    console.log(data.length);\n    return data;\n  })\n  .catch(err => {\n    console.log(err.toString());\n    return err.toString();\n  });\n};\n```\n\nSince we know that “imdbRating”, “genres” and “rated” are mandatory, we can assume that they will always come as parameters and therefore we assign them directly to our *aggregation*. For the “languages” field as it is optional, we will have to verify that there is indeed an associated value and if not we will send default values.\n\nNow we can test this query in our external GraphQL client. The query would look like this (to get the same results as at the beginning):\n\n```\nquery {\n  oneTitleMovies(input: {\n      imdbRating: 7\n      genres: [\n          "Crime"\n          "Horror"\n      ]\n      rated: [\n          "PG"\n          "G"\n      ]\n      languages: [\n          "English"\n          "Japanese"\n      ]\n  }) {\n      title\n  }\n}\n```\n\nFrom here we can play with the different fields of our input to filter our results. One of the advantages of using GraphQL as a replacement for a Rest API is that the fields or response values can be selected in advance. In our example above, we are only returning the “title” field, but we could return a subset of all the fields in the “Movies” collection.\n\n## Wrapping up\n\nRealm GraphQL is a powerful tool to create serverless applications that can easily cover all your basic and complex use cases. Using Realm as a BaaS can help you build and deploy applications faster than ever.\n\nIn this tutorial, we have learned how to create a custom resolver linked to a function to resolve an aggregation pipeline. You can simply adapt this example to your own complex use case.\n\nQuestions? Comments? We\'d love to connect with you. Join the conversation on the [MongoDB Community Forums.](https://developer.mongodb.com/community/forums/c/realm/9)\n\n## Download example code from GitHub\n\nYou can download the sample code from [here](https://github.com/josmanperez/realmGraphQLCustomResolverDemo) and [import](https://docs.mongodb.com/realm/deploy/realm-cli-reference/) it into your Realm application with\n\n``` bash\nrealm-cli import \\\n  --app-id=myapp-abcde \\\n  --path=./path/to/app/dir \\\n  --strategy=merge \\\n  --include-hosting \\\n  --include-dependencies\n```',
  name: "Realm GraphQL Demo: Custom Resolvers",
  description:
    "The aim of this tutorial is to learn how to use Custom Resolvers for complex use cases.",
  calculated_slug: "/products/realm/realm-graphql-demo-custom-resolvers",
  date: "2021-05-25T14:26:19.333Z",
  image: {
    url: "https://images.contentstack.io/v3/assets/blt39790b633ee0d5a7/blt7293c5324cecd628/647a2ae9d5884b36dd7e942d/realm-logo.jpeg",
    alternativeText: "MongoDB Realm Logo",
  },
  authors: [
    {
      name: "Josman Pérez Expóstio",
      image: {
        url: "https://images.contentstack.io/v3/assets/blt39790b633ee0d5a7/bltb630ef83551ad0d3/647a30bdc7e87acdbe3572ab/https_miro.medium.com_fit_c_96_96_1_QVsQtGvB0HlailnBzvtkKQ.jpeg",
        alternativeText: "",
      },
    },
  ],
  tags: [
    {
      name: "Realm",
      type: "L1Product",
      slug: "/products/realm",
    },
    {
      name: "MongoDB",
      type: "AuthorType",
      slug: "/author-types/mongodb",
    },
    {
      name: "Tutorial",
      type: "ContentType",
      slug: "/tutorials",
    },
    {
      name: "Advanced",
      type: "ExpertiseLevel",
      slug: "/expertise-levels/advanced",
    },
    {
      name: "English",
      type: "SpokenLanguage",
      slug: "/spoken-languages/english",
    },
    {
      name: "GraphQL",
      type: "Technology",
      slug: "/technologies/graphql",
    },
  ],
  type: "Tutorial",
  rating_metrics: {
    average: null,
    median: null,
    count: 0,
  },
};
