.. _cpp-driver-indexing:

=========
Indexing
=========

.. facet::
:name: genre
:values: reference

.. meta::
:keywords: MongoDB C++ Driver, code example, Atlas Search

.. contents:: On this page
:local:
:backlinks: none
:depth: 2
:class: singlecol

Overview
--------

In MongoDB, ``indexes`` are data structures that empower you to execute queries
efficiently. MongoDB provides several types of indexes as well as combinations of different types.

Without indexes, MongoDB must traverse all documents in a collection to find
the documents that match each query. This process proves to be heavy and can
negatively impact your application's performance. By using an index to refine the range of
documents MongoDB needs to scan, queries are executed faster than before.

Query Coverage and Performance
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When you execute a query against MongoDB, your query can include three
parts:

- query criteria that specify field(s) and value(s) you are looking for
- options that affect the query's execution, such as read concern
- projection criteria of to specify the fields MongoDB should return (optional)

When all the fields specified in the query criteria and projection of a
query are indexed, MongoDB returns results directly from the index
without scanning any documents in the collection or loading them into
memory.

To ensure your index covers your query
criteria and projection, see the MongoDB manual articles on
:manual:`query coverage </core/query-optimization/#read-operations-covered-query>`
and :manual:`index intersection </core/index-intersection>`.

Operational Considerations
~~~~~~~~~~~~~~~~~~~~~~~~~~

To improve query performance, build indexes on fields that appear often in
your application's queries and operations that return sorted results.
Each index that you add consumes disk space and memory when active so you
should track index memory and disk usage for capacity planning. In addition,
when a write operation updates an indexed field, MongoDB also has to update
the related index.

For more information on designing your data model and choosing indexes
appropriate for your application, see the MongoDB server documentation on
:manual:`Indexing Strategies </applications/indexes>` and
:manual:`Data Modeling and Indexes </core/data-model-operations/#data-model-indexes>`.

Single Field Indexes
~~~~~~~~~~~~~~~~~~~~

**Single field indexes** are indexes on one field only. These indexes enhance the performance
of queries that involve sorting on the said field.

The following example uses the ``createIndex()`` method to create an
ascending order index on the ``name`` field in the ``customers`` collection.

.. code-block:: c++

mongocxx::options::index index_options{};
index_options.ascending("name");

auto index_spec = bsoncxx::builder::stream::document{}
                     << "name" << 1 <<
                  bsoncxx::builder::stream::finalize;

mongocxx::client client{mongocxx::uri{}};
auto coll = client["database"]["customers"];
auto result = coll.create_index(index_spec.view(), index_options);

The following is an example of a query that would be covered by the index
created above.

.. code-block:: c++

auto results = coll.find(document{} << "name" << "John Doe" << finalize);

To learn more, see :manual:`Single Field Indexes </core/index-single>`.

Compound Indexes
~~~~~~~~~~~~~~~~

**Compound indexes** are indexes on multiple fields. These indexes are useful for optimizing queries that
operate on multiple fields.

The following code creates a compound
index on the ``gender`` and ``age`` fields in the ``persons`` collection. The index is sorted by ``age`` in
ascending order and ``gender`` in descending order.

.. code-block:: c++

mongocxx::options::index index_opts{};
index_opts.ascending("age");
index_opts.descending("gender");

auto index_spec = bsoncxx::builder::stream::document{}
                     << "age" << 1 <<
                     "gender" << -1 <<
                     bsoncxx::builder::stream::finalize;

mongocxx::client client{mongocxx::uri{}};
auto coll = client["database"]["persons"];
auto result = coll.create_index(index_spec.view(), index_opts);

To learn more, see :manual:`Compound Indexes </core/index-compound>`.

Multikey Indexes (Indexes on Array Fields)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Multikey indexes** are indexes that improve the performance of queries on
fields that contain array values.

You can create a multikey index on a field with an array value by
calling the ``createIndex()`` method. The following code creates a descending
index on the ``pets.kind`` field in the ``persons`` collection.

.. code-block:: c++

mongocxx::options::index index_opts{};

auto index_spec = bsoncxx::builder::stream::document{}
                     << "pets.kind" << -1 <<
                  bsoncxx::builder::stream::finalize;

mongocxx::client client{mongocxx::uri{}};
auto coll = client["database"]["persons"];
auto result = coll.create_index(index_spec.view(), index_opts);

The following code queries the multikey index to find
documents with a ``pets.kind`` field value that is "hamster":

.. code-block:: c++

auto cursor = coll.find(document{} << "pets.kind" << "hamster" << finalize);

Multikey indexes behave differently from non-multikey indexes in terms of
query coverage, index bound computation, and sort behavior. For a full
explanation of multikey indexes, including a discussion of their behavior
and limitations, refer to the :manual:`Multikey Indexes page
</core/index-multikey>` in the MongoDB Server manual.

Clustered Indexes
~~~~~~~~~~~~~~~~~

**Clustered indexes** are indexes that store documents in a way that the documents are ordered by some key value.
MongoDB doesn't support clustered indexes natively, but you can mimic the behavior to some extent by sorting documents
based on the indexed field.

To ensure your collection is sorted with the index, specify the indexed field as the sort field for all queries.

To learn more, see
:v6.0:`Clustered Collections </core/clustered-collections>`.

Text Indexes
~~~~~~~~~~~~

**Text indexes** support text search queries on fields containing string content.

The following example uses the ``createIndex()`` method to create a text index on the ``content`` field in the
``blogPosts`` collection.

.. code-block:: c++

mongocxx::options::index index_opts{};
index_opts.weights(bsoncxx::from_json(R"(
  {
    "content": 10,
    "title": 5
  }
)"));

auto index_spec = bsoncxx::builder::stream::document{}
                     << "content" << "text" <<
                     bsoncxx::builder::stream::finalize;

mongocxx::client client{mongocxx::uri{}};
auto coll = client["database"]["blogPosts"];
auto result = coll.create_index(index_spec.view(), index_opts);

To learn more, see :manual:`Text Indexes </core/index-text>`.

Geospatial Indexes
~~~~~~~~~~~~~~~~~~

MongoDB supports queries of geospatial coordinate data using **2dsphere
indexes**. With a 2dsphere index, you can query the geospatial data for
intersection and proximity search. For more information on querying
geospatial data with the MongoDB C++ driver, read our
:doc:`Search Geospatial </fundamentals/crud/read-operations/geo>` guide.

To create a 2dsphere index, you must specify a field that contains
only **GeoJSON objects**.

The following example uses the ``createIndexes()`` method to create a
``2dsphere`` index on the ``location.geo`` field in the ``theaters``
collection in the ``sample_mflix`` database to enable geospatial searches.

.. code-block:: c++

mongocxx::options::index index_opts{};
index_opts.bits(32);

auto index_spec = bsoncxx::builder::stream::document{}
                     << "location.geo" << "2dsphere" << bsoncxx::builder::stream::finalize;

mongocxx::client client{mongocxx::uri{}};
auto coll = client["database"]["theaters"];
auto result = coll.create_index(index_spec.view(), index_opts);

MongoDB also supports ``2d`` indexes for calculating distances on a
Euclidean plane and for working with the "legacy coordinate pairs" syntax
used in MongoDB 2.2 and earlier. To learn more, see
:manual:`Geospatial Queries </geospatial-queries>`.

Unique Indexes
~~~~~~~~~~~~~~

**Unique indexes** ensure that the indexed fields do not store duplicate
values. By default, MongoDB creates a unique index on the ``_id`` field
during the creation of a collection. To create a unique index, specify the
field or combination of fields that you want to prevent duplication on and
set the ``unique`` option to ``true``.

The following example uses the ``createIndex()`` method to create a unique
index on the ``email`` field in the ``customers`` collection in the
``sample_mflix`` database.

.. code-block:: c++

mongocxx::options::index index_opts{};
index_opts.unique(true);

auto index_spec = bsoncxx::builder::stream::document{}
                     << "email" << 1 <<
                  bsoncxx::builder::stream::finalize;

mongocxx::client client{mongocxx::uri{}};
auto coll = client["database"]["customers"];
auto result = coll.create_index(index_spec.view(), index_opts);

If you attempt to perform a write operation that stores a duplicate value
that violates the unique index, MongoDB will throw an error that resembles
the following:

.. code-block:: none
:copyable: false

E11000 duplicate key error index

To learn more, see :manual:`Unique Indexes </core/index-unique>`.

Search Indexes
--------------

Atlas Search is a feature that allows you to perform full-text
searches. To learn more, see the :ref:`Atlas Search <fts-top-ref>`
documentation.

Before you can perform a search on an Atlas collection, you must first
create an Atlas Search index on the collection. An Atlas Search
index is a data structure that categorizes data in a searchable format.

You can use the following methods to manage your Search indexes:

- ``createSearchIndex()``
- ``createSearchIndexes()``
- ``listSearchIndexes()``
- ``updateSearchIndex()``
- ``dropSearchIndex()``

The following sections provide code samples that use each of the preceding
methods to manage Search indexes.

Create a Search Index
~~~~~~~~~~~~~~~~~~~~~

You can use the `createSearchIndex()
<{+api+}/classes/Collection.html#createSearchIndex>`__ and
`createSearchIndexes() <{+api+}/classes/Collection.html#createSearchIndexes>`__
methods to create new Search indexes.

The following code shows how to
use the ``createSearchIndex()`` method to create an index called
``search1``:

.. code-block:: c++

mongocxx::options::index index_opts{};

auto index_spec = bsoncxx::builder::stream::document{}
                     << "field_name" << "autocomplete" <<
                  bsoncxx::builder::stream::finalize;

mongocxx::client client{mongocxx::uri{}};
auto coll = client["database"]["collection_name"];
auto result = coll.create_search_index(index_spec.view(), index_opts);

List Search Indexes
~~~~~~~~~~~~~~~~~~~

You can use the `listSearchIndexes()
<{+api+}/classes/Collection.html#listSearchIndexes>`__
method to return a cursor that contains the Search indexes of a given
collection.

The following code uses the ``listSearchIndexes()`` method to list the
Search indexes in a collection:

.. code-block:: c++

auto coll = client["database"]["collection_name"];
auto cursor = coll.list_search_indexes();

Update a Search Index
~~~~~~~~~~~~~~~~~~~~~

You can use the `updateSearchIndex()
<{+api+}/classes/Collection.html#updateSearchIndex>`__ method to update a Search
index.

The following code shows how to
use the ``updateSearchIndex()`` method to update an index called
``search1`` to specify a string type for the ``description`` field:

.. code-block:: c++

mongocxx::options::index update_opts{};
update_opts.description("final_desc");

auto coll = client["database"]["collection_name"];
auto result = coll.update_search_index("name_of_index", update_opts);

Drop a Search Index
~~~~~~~~~~~~~~~~~~~

You can use the `dropSearchIndex()
<{+api+}/classes/Collection.html#dropSearchIndex>`__ method to remove a Search
index.

The following code shows how to
use the ``dropSearchIndex()`` method to remove an index called
``search1``:

.. code-block:: c++

auto coll = client["database"]["collection_name"];
auto result = coll.drop_search_index("name_of_index");